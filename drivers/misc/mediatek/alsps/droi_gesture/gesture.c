/* Copyright Statement: * * This software/firmware and related documentation ("Droi Software") are * protected under relevant copyright laws. The information contained herein * is confidential and proprietary to MediaTek Inc. and/or its licensors. * Without the prior written permission of MediaTek inc. and/or its licensors, * any reproduction, modification, use or disclosure of MediaTek Software, * and information contained herein, in whole or in part, shall be strictly prohibited. * * gesture.c -  driver * * Author: huangjun <huangjun@droi.com> * * This software is licensed under the terms of the GNU General Public * License version 2, as published by the Free Software Foundation, and * may be copied, distributed, and modified under those terms. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * */#include <linux/input.h>#include <linux/module.h>#include <linux/delay.h>#include <linux/device.h>#include <linux/mutex.h>#include <hwmsensor.h>#include <hwmsen_dev.h>#include <hwmsen_helper.h>#include <sensors_io.h>#include <linux/droi_gesture.h>#define __MODE__ "DROI_GESTURE"#define HDEBUG#ifdef HDEBUG	#ifdef __MODE__		#define debug(fmt,arg...) do {\			printk("#h#j# %s::%s "fmt,__MODE__,__func__,##arg);\		}while(0);		#define logerr(fmt,arg...) do {\			printk(KERN_ERR"#h#j# %s::%s "fmt,__MODE__,__func__,##arg);\		}while(0);	#else		#define debug(fmt,arg...) printk("#h#j# [%s ]"fmt,__func__,##arg)		#define logerr(fmt,arg...) printk(KERN_ERR"#h#j# %s "fmt,__func__,##arg);	#endif#else#define debug(fmt,arg...)#define logerr(fmt,arg...) printk(KERN_ERR"#h#j# %s "fmt,__func__,##arg);#endifenum {	USER_ANDROID=(1 << 0),	USER_LINUX=(1 << 1),};struct droi_gesture{	char 			name[8];	char 			probed;	unsigned char	ges_user;	char			now_dir;	struct mutex 	lock;	struct hwmsen_object 	hwobj;	struct input_dev *dev;	struct sensor_ops *ops;#define enable		ops->enable#define getdata		ops->getdata};static struct droi_gesture dgobj;static int droi_gesture_en(struct droi_gesture *dg,bool en,unsigned char who){	int ret = 0;	if(!dg->probed){		logerr("droi gesture not probed!\n");		return ret;	}	mutex_lock(&dgobj.lock);	if(dg->ops && dg->enable && ((ret=dg->enable(en)) == 0))		en > 0?	(dgobj.ges_user |= who) : (dgobj.ges_user &= ~who);//success	mutex_unlock(&dgobj.lock);	return ret;}static int droi_gesture_getdata(struct droi_gesture *dg){	static char count;	int ret = GES_NON_EFFECT;	if(!dg->probed){		logerr("droi gesture not probed!\n");		ret = -1;	}else if(dg->ops && dg->getdata){		if(count)			ret = 0;		else{			mutex_lock(&dg->lock);			ret = dg->getdata();			if(ret < 0) {				ret = GES_NON_EFFECT;				logerr("droi gesture get data fail!\n");			}			mutex_unlock(&dg->lock);		}		count = !count;	}	mdelay(5);	return ret;}static int droi_gesture_ops(void* self, uint32_t command, void* buff_in, int size_in,		void* buff_out, int size_out, int* actualout){	int ret = 0;	int value;	struct hwm_sensor_data* sensor_data;	struct droi_gesture *obj = (struct droi_gesture *)self;	switch (command)	{		case SENSOR_DELAY:			if((buff_in == NULL) || (size_in < sizeof(int)))				ret = -EINVAL;			break;		case SENSOR_ENABLE:			if((buff_in == NULL) || (size_in < sizeof(int)))			{				logerr("Droi gesture enable sensor parameter error!\n");				ret = -EINVAL;			}			else			{				value = *(int *)buff_in;				ret = droi_gesture_en(obj,(bool)value,USER_ANDROID);			}			break;		case SENSOR_GET_DATA:			if((buff_out == NULL) || (size_out< sizeof(struct hwm_sensor_data)))			{				//logerr("Droi gesture get sensor data parameter error! hwobj.polling=0\n");				ret = -EINVAL;			}			else			{				sensor_data = (struct hwm_sensor_data *)buff_out;				if(obj->hwobj.polling == 0)					sensor_data->values[0] = dgobj.now_dir;				else					sensor_data->values[0] = droi_gesture_getdata(obj);				sensor_data->values[1] = !sensor_data->values[0];				sensor_data->value_divide = 1;				sensor_data->status = SENSOR_STATUS_ACCURACY_MEDIUM;				debug("ges value=%d\n",sensor_data->values[0]);			}			break;		default:			logerr("Droi gesture sensor operate function no this parameter %d!\n", command);			ret = -1;			break;	}	return ret;}static ssize_t dg_state_show(struct class *class, struct class_attribute *attr,		char *buf){	return sprintf(buf,"%s\n",(dgobj.ges_user & USER_LINUX)?"enable":"disable");}static ssize_t dg_state_store(struct class *class, struct class_attribute *attr,		const char *buf, size_t count){	bool value;	if (strtobool(buf, &value)) {		return -EINVAL;	}	if(droi_gesture_en(&dgobj,value,USER_LINUX))		logerr("droi gesure linux user open fail\n");	return count;}static CLASS_ATTR(astp,0664,dg_state_show,dg_state_store);static void dgat_down(int x, int y){	input_report_abs(dgobj.dev, ABS_MT_PRESSURE, 100);	input_report_abs(dgobj.dev, ABS_MT_TOUCH_MAJOR, 100);	/* track id Start 0 */	input_report_abs(dgobj.dev, ABS_MT_TRACKING_ID, 0);	input_report_key(dgobj.dev, BTN_TOUCH, 1);	input_report_abs(dgobj.dev, ABS_MT_POSITION_X, x);	input_report_abs(dgobj.dev, ABS_MT_POSITION_Y, y);	input_mt_sync(dgobj.dev);	input_sync(dgobj.dev);}static void dgat_up(int x, int y){	//input_report_abs(tpd->dev, ABS_MT_PRESSURE, 0);	input_report_key(dgobj.dev, BTN_TOUCH, 0);	//input_report_abs(tpd->dev, ABS_MT_TOUCH_MAJOR, 0);	input_mt_sync(dgobj.dev);	input_sync(dgobj.dev);}static void droi_gestrue_report_ges(int ges_report){	struct hwm_sensor_data hsd;	unsigned long lh,lw;	int x1, y1, x2, y2;	int delta_x, delta_y, i,xa=0,ya=0,sx=0,sy=0;	x1 = y1 = x2 = y2 = 0;	switch (ges_report) {	case GES_DOWN:		debug("#North\n");		x1 = x2 = 400;		y1 = 300;		y2 = 100;		xa=0;		ya=-1;		break;	case GES_RIGHT:		debug("#East\n");		x1 = 200;		x2 = 400;		y1 = y2 = 200;		xa=1;		ya=0;		break;	case GES_UP:		debug("#South\n");		x1 = x2 = 400;		y1 = 100;		y2 = 300;		xa=0;		ya=1;		break;	case GES_LEFT:		debug(" #West\n");		x1 = 400;		x2 = 200;		y1 = y2 = 200;		xa=-1;		ya=0;		break;	}	if((dgobj.ges_user & USER_ANDROID) && 0 == dgobj.hwobj.polling){		hsd.values[0] = ges_report;		hsd.values[1] = hsd.values[2] = 0;		hsd.value_divide=1;		dgobj.now_dir = hsd.values[0];		hwmsen_get_interrupt_data(ID_DROI_GESTURE,&hsd);		mdelay(2);	}	if((dgobj.ges_user & USER_LINUX) && dgobj.dev && (ges_report > GES_NON_EFFECT && ges_report <= GES_DOWN)){		delta_x = (x2 - x1) / 5;		delta_y = (y2 - y1) / 5;		if(kstrtoul(CONFIG_LCM_HEIGHT,10,&lh) < 0)			lh = 1280;		if(kstrtoul(CONFIG_LCM_WIDTH,10,&lw) < 0)			lw = 720;		y1 = lh / 2 + 100;		x1 = lw / 2;		xa*=80;		ya*=80;		i = 0;		while(!(sx > lw || sx < 0 ||sy > lh || sy < 0)) {			sx=(x1  + (xa*i*i)/2);			sy=(y1  + (ya*i*i)/2);			dgat_down(sx,sy);			i++;		}		mdelay(1);		dgat_up(sx,sy);	}}void droi_gestrue_trigger(int ge){	droi_gestrue_report_ges(ge);}EXPORT_SYMBOL_GPL(droi_gestrue_trigger);int droi_gesture_ops_register(struct sensor_ops *ops){	int ret = 0;	if(!dgobj.ops)		dgobj.ops = ops;	else ret = -1;	return ret;}EXPORT_SYMBOL_GPL(droi_gesture_ops_register);int droi_gesture_input_register(struct input_dev *dev){	int ret = 0;	if(!dgobj.dev)		dgobj.dev = dev;	else ret = -1;	return ret;}EXPORT_SYMBOL_GPL(droi_gesture_input_register);static int __init droi_gesture_init(void){	int ret = 0;	struct class *dgclass;	mutex_init(&dgobj.lock);	dgobj.hwobj.self=&dgobj;#ifdef REPORT_TRIGGER	dgobj.hwobj.polling=0;#else	dgobj.hwobj.polling=1;#endif	dgobj.hwobj.sensor_operate = droi_gesture_ops;	if((ret = hwmsen_attach(ID_DROI_GESTURE, &dgobj.hwobj)) != 0){		logerr("attach fail = %d\n", ret);	}else{		dgclass = class_create(THIS_MODULE,"droi_gesture");//this need do changes,not good		if(!class_create_file(dgclass,&class_attr_astp))			dgobj.probed = 1;	}	return ret;}late_initcall(droi_gesture_init);MODULE_AUTHOR("HUANGJUN");MODULE_DESCRIPTION("droi virtual sensor depends on proximity or gesture sensor driver");MODULE_LICENSE("GPL");